# --------------------------------------------------------------------------------------------
# set 데이터 타입
# - 제일 마지막에 추가된 타입
# - 목적: 중복 데이터 제거
# - 특징: 이미 존재하는 데이터는 저장하지 않음!!
# - 문법: { 데이터1, 데이터2, ..., 데이터n }
# --------------------------------------------------------------------------------------------

# 빈 데이터 타입 생성 ==========================================================================
aList = []
aTuple = ()
aDict = {}
aSet = set()

print(f'aList => {type(aList)}, {len(aList)}개')
print(f'aTuple => {type(aTuple)}, {len(aTuple)}개')
print(f'aDict => {type(aDict)}, {len(aDict)}개')
print(f'aSet => {type(aSet)}, {len(aSet)}개')

# ----------------------------------------------------------------------------------------------
# 생성자 매서드 => 타입 이름과 동일한 함수명
# - 힙 영역 메모리 공간 잡고 데이터 초기화 기능 수행
# ----------------------------------------------------------------------------------------------
print('#'*30)
aList = list()
aTuple = tuple()
aDict = dict()
aSet = set()
aStr = ''

print(f'aList => {type(aList)}, {len(aList)}개')
print(f'aTuple => {type(aTuple)}, {len(aTuple)}개')
print(f'aDict => {type(aDict)}, {len(aDict)}개')
print(f'aSet => {type(aSet)}, {len(aSet)}개')
print(f'aStr => {type(aStr)}, {len(aStr)}개')

# ------------------------------------------------------------------------------------------------
# set 타입의 데이터 생성
# ------------------------------------------------------------------------------------------------
a1 = {1,1,2,3,4,5,1,1,1,1}
a2 = {1,1,2,3,4,5,1,1,1,1}

print(f'a1 => {type(a1)}, {len(a1)}개, {a1}') # 중복된 값이 저장되지 않아 출력 되지도 않음
print(f'a2 => {type(a2)}, {len(a2)}개, {a2}')

# 다른 데이터 타입에서 중복 데이터 제거 시에 활용 => 형변환!!
a2 = list(set(a2))
print(f'a2 => {type(a2)}, {len(a2)}개, {a2}')


# -------------------------------------------------------------------------------------------------
# set 타입의 연산 수행: 중복이 되지 않기 때문에 곱셈, 덧셈 등 연산 안됨 >> 형변환해서 계산해야 함.
# -------------------------------------------------------------------------------------------------
a1 = {1, 3, 5, 1, 2}
b1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# 연산 수행 => 형변환 후 수행
# a1 = list(a1)
# print(a1*)

# --------------------------------------------------------------------------------------------------
# 원소/요소 읽기/수정/삭제/추가 => 인덱스x, 키x => 대신 메서드 제공
# --------------------------------------------------------------------------------------------------
# 원소/요소 추가 => 1개 추가: add() 메서드
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')
a1.add(10)
a1.add(10)
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')

a1.add('A')
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')

# 여러 개의 원소/요소 추가 => update() 메서드
a1.update([11, 22, 33, 44])
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}') # set은 순서가 없어서 매번 순서가 다르게 출력될 수도 있음

a1.update("Good Luck !!")
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}') # 각 문자가 따로 저장되며, 중복은 제거된다.

a1.add("Good Luck !!") # add의 경우, 1개만 추가하는 것이므로 문장 전체를 하나로 보고 한번에 추가함.
print(f'a1 => {type(a1)}, {len(a1)}개, {a1}')


# 원소/요소 삭제 => remove(데이터)
a1.remove('G')
print(f'[remove] a1 => {type(a1)}, {len(a1)}개, {a1}')


# 원소/요소 꺼내기 => pop() >> remove와 다른 점은 꺼냈기 때문에 출력이 있음.
data = a1.pop()
print(f'a1 => {data}, {type(a1)}, {len(a1)}개, {a1}')

data = a1.pop()
print(f'a1 => {data}, {type(a1)}, {len(a1)}개, {a1}')

data = a1.pop()
print(f'a1 => {data}, {type(a1)}, {len(a1)}개, {a1}')


# ------------------------------------------------------------------------------------------------
# 집합에 관련된 메서드들과 기호 / 연산자
# ------------------------------------------------------------------------------------------------

# 교집합 ==========================================================================================
# - 여러 개의 집합에 공통으로 존재하는 데이터만 추출
# - 기호/연산자: &(and 연산자)
# - 메서드: intersection()
a1.clear()
a1.update("Happy")
print(f'a1 => {a1}')

a2 = a1.intersection({'a', 'A', 'b', 'B'})
print(f'a2 => {a2}')
print(a1 & {'a', 'A', 'b', 'B'})

# 합집합 ==========================================================================================
# - 여러 개의 집합에서 중복은 1개만 포함한 모든 원소의 집합
# - 기호/연산자: |(or 연산자)
# - 메서드: union()
a2 = a1.union({'a', 'A', 'b', 'B'})
print(f' a2 => {a2}', a1 | {'a', 'A', 'b', 'B'})

# 차집합 ==========================================================================================
# - 교집합 데이터 제외한 나머지 데이터
# - 기호/연산자: -(뺄셈 연산자)
# - 메서드: difference()
a2.difference({'a', 'A', 'b', 'B'})
print(f"a2 => {a2}", a1 - {'a', 'A', 'b', 'B'})

a3 = {'a', 'A', 'b', 'B'}.difference(a1)
print(f"a3 => {a3}", {'a', 'A', 'b', 'B'} - a1)

# 정렬 ============================================================================================
# 원소 값을 서로 비교해서 작은 데이터 >> 큰 데이터 순서로 저장 => 오름차순
# 원소 값을 서로 비교해서 큰 데이터 >> 작은 데이터 순서로 저장 => 내림차순
# set 타입에는 정렬 메서드 없음 => 내장함수 sorted() 사용
a1 = sorted(a1) # 반환값으로 list를 줌
print(f'a1 => {type(a1)}, {a1}')